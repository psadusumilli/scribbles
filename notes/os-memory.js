OS MEMORY MGMT
-~~~~~~~~~~~~~~~~~
OS does memory management with 2 registers
    1 'base-register'  holds the smallest legal physical memory address
    2 'limit register' specifies the size of the range
  For example, if the base register holds 300000 and the limit register is 1209000,
  then the program can legally access all addresses from 300000 through 411999

  Instructions and data, to memory addresses can be done in following ways
    1 Compile time -- When it is known at compile time where the process will reside, compile time binding is used to generate the absolute code.
    2 Load time -- When it is not known at compile time where the process will reside in memory, then the compiler generates re-locatable code.
    3 Execution time -- If the process can be moved during its execution from one memory segment to another, then binding must be delayed to be done at run time

'Dynamic Loading'
    In dynamic loading, a routine of a program is not loaded until it is called by the program.
    All routines are kept on disk in a re-locatable load format. The main program is loaded into memory and is executed.
    Other routines methods or modules are loaded on request.
    Dynamic loading makes better memory space utilization and unused routines are never loaded.

'Dynamic Linking'
    Linking is the process of collecting and combining various modules of code and data into a executable file that can be loaded into memory and executed.
    OS can link system level libraries to a program.
    When it combines the libraries at load time, the linking is called 'static linking'  - big program size
    When this linking is done at the time of execution, it is called as 'dynamic linking' - small starting program size

'Logical/Physical Address'
    An address generated by the CPU is a logical/virtual address whereas address actually available on memory unit is a physical address.
    Virtual and physical addresses are the same in compile-time and load-time address-binding schemes but differ in execution-time address-binding scheme.
    MMU (memory management unit) is a hardware to convert virtual address to physical address.

SWAPPING
    Swapping is a mechanism in which a 'process can be swapped temporarily out of main memory to a backing store (usually disk) then back'.
    Major time consuming part of swapping is transfer time. Total transfer time is directly proportional to the amount of memory swapped.
    Say  process is of size 100KB and standard hard disk with transfer rate of 1 MB per second.
    The actual transfer of the 100K process to or from memory will take 100KB / 1000KB per second = 1/10 second = 100 milliseconds

PARTITIONS
  Main memory usually has two partitions
    1 Low Memory -- Operating system resides in this memory.
    2 High Memory -- User processes then held in high memory

FRAGMENTATION
  As processes are loaded and removed from memory, the free memory space is broken into little pieces which need consolidation.
    1	External fragmentation -- 'many useless small pieces' :
       Total memory space is enough to satisfy a request or to reside a process in it, but it is not contiguous so it can not be used.
    2	Internal fragmentation -- 'few big pieces' :
       Memory block assigned to process is bigger. Some portion of memory is left unused as it can not be used by another process.

PAGING
   'External fragmentation' is avoided by Paging which seggregates memory into fixed size blocks called Pages (2 power 512-8192 byte)
   CPU thinks the logical memory is contiguous but Paging maps the logical to fragmented physical pages using a table.
   Address generated by CPU is divided into
       Page number (p) -- page number is used as an index into a page table which contains base address of each page in physical memory.
       Page offset (d) -- page offset is combined with base address to define the physical memory address.

SEGMENTATION
    'Internal fragmention' is avoided by Segmentation where memory is segmented intto logical spaces per process/OS
    Segmentation can be implemented using or without using Paging.
    Address generated by CPU is divided into
        Segment number (s) -- segment number is used as an index into a segment table which contains base address of each segment in physical memory and a limit of segment.
        Segment offset (o) -- segment offset is first checked against limit and then is combined with base address to define the physical memory address.



