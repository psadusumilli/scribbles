JVM Notes
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CHAPTER1: INTRODUCTION
**********************
1.1| 	Java architecture arises out of four distinct but interrelated technologies:
			the Java programming language
			the Java class file format
			the Java Application Programming Interface
			the Java virtual machine
1.2| 	JVM supports all three prongs of Java network-oriented architecture: 'platform independence, security, and network-mobility'.
1.3| 	JVM has a 'Classloader' (to load the byte from classes) and an 'Execution Engine'(to execute the bytecode)
1.4| 	Execution Engine offers many implementations
		Simple Interpretation -> one at a time
		Just In Time Compilation -> bytecode to native machine code just before execution of a method, then saved to future use.
		Adaptive Optimiser -> compile to native code only the heavily used portion of the code.
		Direct Native -> JVM built on top of a chip that executes Java bytecodes natively, the execution engine is actually embedded in the chip.
1.5| 	In Java, there are two kinds of methods: Java and native. 
	A 'Java method' is written in the Java language, compiled to bytecodes, and stored in class files.
	A 'native method' is written in some other language, such as C, C++, or assembly, and compiled to the native machine code of a particular processor. 
	'Native methods' are stored in a dynamically linked library whose exact form is platform specific. While 'Java methods' are platform independent, native methods are not. 
	When a running Java program calls a native method, the virtual machine loads the dynamic library that contains the native method and invokes it.
	Use of 'Native methods' can make your program platform-specific, can be alleviated using 'JNI', but vendors are mandated to implement it.
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CLASS LOADER
*************
2 types are 
	'Bootstrap' -> implemented inside JVM in native code
	'user-defined' -> written by coders in Java
Boundaries exist between classes loaded by different class loaders, only the JVM can co-relate.
CLASS
******
Provides platform-independence and network-mobility, by enabling a common form to be ported to JVMs hosted on different platform

JAVA API
********
API is implemented for different platforms
Consistent primitives across platforms -> Int is always 4byte 
Provides security by using 'Security manager' (1.2) or 'Access Controllers' (1.3+). Any malicious calls are intersected at stack levels by security.
Your program -> Java API -> Native library -> Host OS 

JAVA LANGUAGE
*************
OOP, Garbage Collection, no direct memory handling, only references

ARCHITECTURAL TRADEOFFS
************************
Performance still being worked to be on par with C/C++
Differs for every JVM implementation
Adaptive Optimiser can do only static linking 
Unpredictable Garbage collection and Threads
Dynamic linking of classes is all symbolic links, thereby making it easier to decompile back to source. This makes your code open to competitors
	Can be alleviated by using obfuscation.
	
	'Static linking' is the result of the linker copying all library routines used in the program into the executable image. 
	This may require more disk space and memory than dynamic linking, but is both faster and more portable, 
	since it does not require the presence of the library on the system where it is run.
	
	'Dynamic linking' is accomplished by placing the name of a sharable library in the executable image. 
	Actual linking with the library routines does not occur until the image is run, when both the executable and the library are placed in memory. 
	An advantage of dynamic linking is that multiple programs can share a single copy of the library.	
#--------------------------------------------------------------------------------------------------------------------------------------------	
CHAPTER2: PLATFORM INDEPEDENCE:
********************************
Consistent primitives across platforms -> Int is always 4byte 
Sun initially started Java for embedded systems only has desktops were dominated by MS and Apple
J2ME, J2SE, J2EE
#--------------------------------------------------------------------------------------------------------------------------------------------	
CHAPTER3: SECURITY
*******************
Javas security model is focused on protecting end-users from hostile programs downloaded across a network from untrusted sources. 
To accomplish this goal, Java provides a customizable "sandbox" in which Java programs run. A Java program must play only inside its sandbox. 
It can do anything within the boundaries of its sandbox, but can't take any action outside those boundaries. 
The sandbox for untrusted Java applets, for example, prohibits many activities, including:

    reading or writing to the local disk,
    making a network connection to any but the host from which the applet came,
    creating a new process, and
    loading a new dynamic library and directly calling a native method.
    
The fundamental components responsible for Java's sandbox are:
	the class loader architecture
	the class file verifier
	safety features built into the Java virtual machine (and the language)
	the security manager and the Java API

3.1| 'CLASS LOADER'
-------------------
Each call to load a class, is made first to the primordial class loader(Boot), if it does not find in its trusted store, then trickle down to custom loaders.

Rules to write a custom class loader
	0	Make sure your class loader prevents loading any class that impersonates like 'java.lang' apis
	1	If packages exist that this class loader is not allowed to load from, the class loader checks whether the requested class is in one of those 
		forbidden packages. If so, it throws a security exception. Else, it continues on to step two. 
	2	The class loader passes the request to the primordial class loader. If the primordial class loader successfully returns the class, 
		the class loader returns that same class. Else, it continues on to step three. 
	3	If trusted packages exist that this class loader is not allowed to add classes to, 
		the class loader checks whether the requested class is in one of those restricted packages. 
		If so, it throws a security exception. Else, it continues on to step four. 
	4	Finally, the class loader attempts to load the class in the custom way, such as by downloading it across a network. 
		If successful, it returns the class. Else, it throws a "no class definition found" error.
		
3.2| 'CLASS FILE VERIFIER'
-------------------------
Working in conjunction with the class loader, the class file verifier ensures that loaded class files have a proper internal structure. 
If the class file verifier discovers a problem with a class file, it throws an exception
Two steps:
	After classloading, verifies the integrity of the bytecodes it import
	During execution, confirms the existence of symbolically referenced classes, fields, and methods. 
	
3.2.1| Step1: Internal Checks:
-------------------------------
	Phase one of the class file verifier makes sure the imported class file is properly formed, internally consistent, adheres to the constraints of the Java programming language, and contains bytecodes that will be safe for the Java Virtual Machine to execute. 
	If the class file verifier finds that any of these are not true, it throws an error, and the class file is never used by the program.
	Checks if bytecodes neither truncated nor enhanced with extra trailing bytes. 
	Checks if method descriptor have a context free grammar
	
	The bytecode streams that represent Java methods are a series of one-byte instructions, called opcodes, each of which may be followed by one or more operands. 
	The operands supply extra data needed by the Java Virtual Machine to execute the opcode instruction. 
	The activity of executing bytecodes, one opcode after another, constitutes a thread of execution inside the Java Virtual Machine. 
	Each thread is awarded its own Java Stack, which is made up of discrete frames. 
	Each method invocation gets its own frame, a section of memory where it stores, among other things, local variables and intermediate results of computation. 
	The part of the frame in which a method stores intermediate results is called the methodís operand stack. 
	An opcode and its (optional) operands may refer to the data stored on the operand stack or in the local variables of the methodís frame. 
	Thus, the virtual machine may use data on the operand stack, in the local variables, or both, in addition to any data stored as operands following an opcode when it executes the opcode.
	
3.2.2| STEP2: Verfication of symbolif references	
------------------------------------------------
Dynamic linking is the process of resolving symbolic references into direct references.
As the JVM executes bytecodes and encounters an opcode that, for the first time, uses a symbolic reference to another class, the virtual machine must resolve the symbolic reference. 
The virtual machine performs two basic tasks during resolution:
    a) find the class being referenced (loading it if necessary)
    b) replace the symbolic reference with a direct reference, such as a pointer or offset, to the class, field, or method
Throws ClassNotFoundException, MethodNotFoundException for cases when they could not have been detected during compile time.
Also does the following, though the language compiler has already done it
    a) type-safe reference casting
    b) structured memory access (no pointer arithmetic)
    c) automatic garbage collection (canít explicitly free allocated memory)
    d) array bounds checking
    e) checking references for null

#--------------------------------------------------------------------------------------------------------------------------------------------	


